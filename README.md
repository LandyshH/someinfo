## Внедрение в дотнет

1. Можно использовать библиотеку 
https://github.com/build-security/OPA-AspDotNetCore-Middleware/tree/main
или
2. HTTP запросы + свой middleware ( https://medium.com/@anandamit1807/policy-based-authorization-in-asp-net-core-web-api-using-open-policy-agent-4a07888bebc9)

## Поднять OPA сервер

Локально или в кубере

В кубере: 
- Разверните OPA как Pod, Deployment или DaemonSet в вашем Kubernetes-кластере.
- OPA будет доступен как сервис внутри кластера через DNS (например, `opa-service`).
- OPA должен быть настроен в серверном режиме (`--server`), чтобы принимать REST-запросы от ваших микросервисов.

## Написать политики OPA

Rego-политики управляют авторизацией на основе метаданных запросов, таких как путь, метод, пользовательские заголовки и JWT токены.

1. **Создать политику Rego** 
Файл policy.rego
Например, политика для проверки роли и пути из JWT токена
``` rego
package example

default allow = false

# Правила для администраторов
allow {
    input.token.jwt != ""
    [_, claims] := io.jwt.decode(input.token.jwt)
    claims.role == "admin"
}

# Правила для пользователей с ролью "user", ограниченный доступ
allow {
    input.token.jwt != ""
    [_, claims] := io.jwt.decode(input.token.jwt)
    claims.role == "user"
    input.method == "GET"
    startswith(input.path, "/api/public")
}
```

Песочница: https://play.openpolicyagent.org/

2. **Загрузить политику с помощью Put запроса**
   
(пример для локального сервера OPA)
``` bash
curl -X PUT --data-binary @policy.rego http://localhost:8181/v1/policies/example
```

Автоматическая загрузка политик при старте OPA:
Чтобы OPA автоматически загружал политику при запуске, нужно положить файл политики в директорию и указать её при старте:

``` bash
opa run --server --bundle /path/to/policies
```

Файлы политики и данные в директории `/path/to/policies` будут автоматически загружены в OPA.

3. URL получения политики (OPA сам предоставляет API для получения данных:
   https://www.openpolicyagent.org/docs/latest/rest-api): 
``` plaintext
  http://localhost:8181/v1/data/example/allow
```

### Хранение и обновление политик и данных

Политики и данные могут быть загружены в OPA несколькими способами:

a) Хранение политик и данных в OPA

- Политики (Rego) и данные (JSON) хранятся в самом OPA.
- Вы загружаете их через REST API.

b) Внешний источник данных (API)

OPA может обращаться к внешним API для получения данных. Это позволяет централизовать хранение политик и данных.

Примерная конфигурация:
``` yaml
services:
  - name: external-data
    url: https://external-api.example.com

bundles:
  external-bundle:
    service: external-data
    resource: /bundles/policies

decision_logs:
  console: true
```

Здесь:
- **services**: Определяет API, к которому OPA будет обращаться.
- **bundles**: Указывает, что политики и данные будут загружаться как бандлы с внешнего API.

## Обработка запросов

### 1 вариант: Middleware напрямую обращается к OPA

- **Middleware**: Нужно написать своё middleware, чтобы интегрировать OPA в проект.
- **Политики**: Политики описываются в формате `.rego` и управляют доступом.
- **REST API OPA**: Middleware взаимодействует с OPA через REST API.

Пример тут:  https://medium.com/@anandamit1807/policy-based-authorization-in-asp-net-core-web-api-using-open-policy-agent-4a07888bebc9

### 2 вариант: использовать Envoy

#### 1. Централизованное управление доступом

- **Envoy** действует как центральная точка входа для всех запросов, перенаправляя их к соответствующим микросервисам.
- **OPA** проверяет, разрешён ли доступ, на основе политик.
- Вместо того чтобы внедрять логику авторизации в каждый микросервис, вы используете единую точку проверки.
#### 2. Расширяемость через фильтры

Envoy поддерживает мощную систему фильтров, включая:

- **External Authorization Filter (ext_authz)**: Этот фильтр позволяет Envoy делегировать проверку авторизации внешнему сервису, например OPA.
#### 3. Поддержка gRPC для быстрой интеграции с OPA

OPA предоставляет плагин **OPA-Envoy**, который позволяет Envoy взаимодействовать с OPA через gRPC:

- gRPC обеспечивает низкую задержку и эффективное взаимодействие между Envoy и OPA.
- Плагин обрабатывает запросы Envoy и передаёт их в OPA для оценки.
#### 4. Упрощение авторизации для микросервисов

- Без Envoy микросервисы должны сами отправлять запросы в OPA для проверки доступа, что усложняет архитектуру.
- Envoy берёт эту задачу на себя: он вызывает OPA перед тем, как отправить запрос в микросервис.

#### 5. Поддержка Sidecar-паттерна

Envoy и OPA часто используются вместе в рамках Sidecar-паттерна:

- Envoy становится прокси для микросервиса.
- OPA отвечает за проверку политики.
- Это обеспечивает изоляцию авторизационной логики от бизнес-логики.

#### Как работает связка Envoy и OPA

1. **Клиент отправляет запрос**: Клиент отправляет запрос в Envoy (например, через API Gateway или напрямую в Envoy sidecar).

2. **Envoy вызывает OPA**: Envoy использует фильтр `ext_authz`, чтобы отправить запрос в OPA для проверки авторизации.

3. **OPA проверяет политику**:
    - OPA оценивает запрос на основе загруженной Rego-политики.
    - Возвращает решение `allow: true/false`.

4. **Envoy перенаправляет запрос**:
    - Если OPA разрешает доступ (`allow: true`), Envoy отправляет запрос в микросервис.
    - Если доступ запрещён, Envoy возвращает клиенту HTTP 403.

#### Развёртывание OPA и Envoy в Sidecar
Каждый микросервис разворачивается с двумя контейнерами:

1. **Микросервис** — основной контейнер.
2. **Sidecar контейнеры**:
    - Envoy (обрабатывает входящие запросы).
    - OPA (управляет авторизацией).


В таком случае Middleware в c# проекте не будет обращаться к напрямую OPA, а будет обрабатывать запросы, которые уже прошли через Envoy.

## Архитектура

### Авторизация через API Gateway

``` plaintext
[Client] -> [API Gateway] -> [OPA] -> [Microservice] -> [Database]
```

1. Клиент отправляет запрос в **API Gateway**.
2. **API Gateway** перенаправляет данные (путь, метод, заголовки) в OPA.
3. **OPA** проверяет запрос на основе загруженных политик и возвращает решение.
4. Если доступ разрешён, **API Gateway** отправляет запрос в микросервис.
5. Микросервис обрабатывает запрос и взаимодействует с базой данных.

### Sidecar (Envoy + OPA)

``` plaintext
[Client] -> [API Gateway] -> [Envoy Sidecar + OPA] -> [Microservice] -> [Database]
```

1. **Envoy Sidecar** развёрнут рядом с каждым микросервисом.
2. Все запросы к микросервису проходят через Envoy.
3. **Envoy** вызывает OPA для проверки доступа.
4. Если OPA разрешает доступ, запрос передаётся в микросервис.

### Встроенная авторизация в микросервис

``` plaintext
[Client] -> [API Gateway] -> [Microservice] -> [OPA] -> [Database]
```

1. **API Gateway** отправляет запрос в микросервис.
2. Микросервис вызывает OPA для проверки авторизации.
3. **OPA** возвращает решение.
4. Если доступ разрешён, микросервис обрабатывает запрос.
